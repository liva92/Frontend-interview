### 1、计数算法

1.1 算法思想：

量大但是范围小，如

+ 某企业数万名员工年龄排序
+ 如何快速得知高考名次

1.2 其数据如下:
  最佳情况：T(n) = O(n+k)
  最差情况：T(n) = O(n+k)
  平均情况：T(n) = O(n+k)

1.3 计数排序的步骤如下:

1. 查找*待排序*数组中最大和最小的元素
2. 统计每个值为i的元素的出现次数
3. 对所有计数开始累加(从min开始,每一项和前一项相加)
4. 反向填充目标数组,将每个元素i放在新数组的第C[i]项,每放一个元素,计数-1.

```javascript
function countingSort(arr) {
        var len = arr.length,
          Result = [],
          Count = [],
          min = (max = arr[0]);
        console.time('countingSort waste time:');
        /*查找最大最小值,并将arr数置入Count数组中,统计出现次数*/
        for (var i = 0; i < len; i++) {
          Count[arr[i]] = Count[arr[i]] ? Count[arr[i]] + 1 : 1;
          min = min <= arr[i] ? min : arr[i];
          max = max >= arr[i] ? max : arr[i];
        }
        /*从最小值->最大值,将计数逐项相加*/
        for (var j = min; j < max; j++) {
          Count[j + 1] = (Count[j + 1] || 0) + (Count[j] || 0);
        }
        /*Count中,下标为arr数值,数据为arr数值出现次数;反向填充数据进入Result数据*/
        for (var k = len - 1; k >= 0; k--) {
          /*Result[位置] = arr数据，Count[arr[k]]-1为arr[k]的下标位置*/
          Result[Count[arr[k]] - 1] = arr[k];
          /*减少Count数组中保存的计数*/
          Count[arr[k]]--;
        }
        console.timeEnd('countingSort waste time:');
        return Result;
      }
      var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];
      console.log(countingSort(arr));

```



### 桶排序

桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：

1. 在额外空间充足的情况下，尽量增大桶的数量
2. 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中 

同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。

**什么时候最快**

 当输入的数据可以均匀的分配到每一个桶中。

**什么时候最慢** 

当输入的数据被分配到了同一个桶中。

**示意图**

<img src="C:\Users\67564\Desktop\面试\Frontend-interview\images\sort00.png" alt="sort00" style="zoom:50%;" />

```javascript
function bucketSort(arr, bucketSize) {
    if (arr.length === 0) {
      return arr;
    }

    var i;
    var minValue = arr[0];
    var maxValue = arr[0];
    for (i = 1; i < arr.length; i++) {
      if (arr[i] < minValue) {
          minValue = arr[i];                // 输入数据的最小值
      } else if (arr[i] > maxValue) {
          maxValue = arr[i];                // 输入数据的最大值
      }
    }

    //桶的初始化
    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5
    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;
    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;   
    var buckets = new Array(bucketCount);
    for (i = 0; i < buckets.length; i++) {
        buckets[i] = [];
    }

    //利用映射函数将数据分配到各个桶中
    for (i = 0; i < arr.length; i++) {
        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);
    }

    arr.length = 0;
    for (i = 0; i < buckets.length; i++) {
        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序
        for (var j = 0; j < buckets[i].length; j++) {
            arr.push(buckets[i][j]);                      
        }
    }

    return arr;
}
```

